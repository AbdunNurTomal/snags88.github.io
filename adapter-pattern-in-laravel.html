<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>The Adapater Pattern in Laravel</title> <meta name="description" content="Now that we‚Äôve finished the creational patterns, we‚Äôre moving on tostructural patterns. These patterns focus primarily on the compositionof classes and objec..."> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="http://snags88.github.io/adapter-pattern-in-laravel"> <link rel="alternate" type="application/rss+xml" title="gem install Seiji" href="http://snags88.github.io/feed.xml"> <script src="/assets/js/modernizr.js"></script> </head> <body"> <main class="wrapper"> <header class="site-header"> <a href="#navbar" id="menu-burger" class="menu-burger">Menu <span class="nav-icon"></span> <svg x="0px" y="0px" width="54px" height="54px" viewBox="0 0 54 54"> <circle fill="transparent" stroke="#000000" stroke-width="1" cx="27" cy="27" r="25" stroke-dasharray="157 157" stroke-dashoffset="157"></circle> </svg> </a> <div id="navbar" class="navbar"> <div class="navigation-wrapper"> <div class="half-block"> <h2>Navigation</h2> <nav> <ul class="no-style primary-nav"> <li><a href="/">Home</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/about">About</a></li> <li><a href="http://github.com/snags88" target="_blank"><i class="icon icon-github"></i> Github</a></li> <li><a href="http://linkedin.com/in/snaganuma" target="_blank"><i class="icon icon-linkedin"></i> LinkedIn</a></li> <li><a href="http://twitter.com/S2k10" target="_blank"><i class="icon icon-twitter"></i> Twitter</a></li> </ul> </nav> </div> </div> </div> </header> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header intro"> <div class="intro-in"> <h1 class="post-title" itemprop="name headline">The Adapater Pattern in Laravel</h1> <p class="post-meta"><time datetime="2018-05-30T18:51:00-07:00" itemprop="datePublished">May 30, 2018</time></p> </div> </header> <div class="post-content container" itemprop="articleBody"> <p>Now that we‚Äôve finished the creational patterns, we‚Äôre moving on to structural patterns. These patterns focus primarily on the composition of classes and objects in order to create a scaleable structure for the application. There are seven total patterns in this family and we‚Äôll take a look one by one. First up: the Adapter pattern.</p> <h2 id="adapter-pattern">Adapter Pattern</h2> <p>The Adapter pattern is often used when we have preexisting code that needs to be used but doesn‚Äôt have the expected API that the outside world expects. You‚Äôll run into this type of situation a lot when you‚Äôre working with third-party libraries and you need to swap out an old library for a new one (i.e. switching from Nexmo to Twilio for sending SMS). The new library may not have the exact same API as the old, so in this situation, you‚Äôre left with two choices:</p> <ol> <li>Rewrite everything in your app to conform to the library‚Äôs API.</li> <li>Write an adapter or a wrapper around the library to conform to the API your app expects.</li> </ol> <p>In general, even if it‚Äôs your first time using a third-party library, it helps to write a wrapper around the library in case you ever need to swap out the library. For instance, you might name the Twilio library <code class="highlighter-rouge">SmsClientAdapter</code> to keep it generic. Now, your app doesn‚Äôt care if the adapter uses the Twilio library or the Nexmo library.</p> <h2 id="adapter-pattern-in-the-wild-">Adapter Pattern in the Wild üïµÔ∏è</h2> <p>In the world of Laravel, or any large framework for that matter, we are able to choose the data storage that best fits are app‚Äôs needs. One of the storage types in Laravel is Redis, a fast storage solution that can be used for caching or storing simple key-value pairs.</p> <p>In PHP, there are two popular clients for Redis (<a href="https://github.com/phpredis/phpredis" target="_blank">PhpRedis</a> and <a href="https://github.com/nrk/predis" target="_blank">Predis</a>) that Laravel lets you choose from. After you configure the Redis driver, Laravel will work its magic and allow you to send commands to your Redis server.</p> <p>I wanted to dig into this code a little bit to see if there was some kind of adapter pattern. We can start at a <code class="highlighter-rouge">RedisManager</code> object in <code class="highlighter-rouge">Illuminate\Redis\RedisManager.php</code>:</p> <figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
  <span class="k">protected</span> <span class="k">function</span> <span class="nf">connector</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">driver</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">'predis'</span><span class="o">:</span>
              <span class="k">return</span> <span class="k">new</span> <span class="nx">Connectors\PredisConnector</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">'phpredis'</span><span class="o">:</span>
              <span class="k">return</span> <span class="k">new</span> <span class="nx">Connectors\PhpRedisConnector</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>Here, you can see that we return connector objects based on the driver we‚Äôve chosen. These connectors aren‚Äôt too interesting, but they both define a <code class="highlighter-rouge">connect</code> function that will return a connection object based on which driver you‚Äôre using:</p> <figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1">// in PhpRedisConnector
</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">connect</span><span class="p">(</span><span class="k">array</span> <span class="nv">$config</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PhpRedisConnection</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createClient</span><span class="p">(</span><span class="nb">array_merge</span><span class="p">(</span>
        <span class="nv">$config</span><span class="p">,</span> <span class="nv">$options</span><span class="p">,</span> <span class="nx">Arr</span><span class="o">::</span><span class="na">pull</span><span class="p">(</span><span class="nv">$config</span><span class="p">,</span> <span class="s1">'options'</span><span class="p">,</span> <span class="p">[])</span>
    <span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// in PredisConnector
</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">connect</span><span class="p">(</span><span class="k">array</span> <span class="nv">$config</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$formattedOptions</span> <span class="o">=</span> <span class="nb">array_merge</span><span class="p">(</span>
        <span class="p">[</span><span class="s1">'timeout'</span> <span class="o">=&gt;</span> <span class="mf">10.0</span><span class="p">],</span> <span class="nv">$options</span><span class="p">,</span> <span class="nx">Arr</span><span class="o">::</span><span class="na">pull</span><span class="p">(</span><span class="nv">$config</span><span class="p">,</span> <span class="s1">'options'</span><span class="p">,</span> <span class="p">[])</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PredisConnection</span><span class="p">(</span><span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="nv">$config</span><span class="p">,</span> <span class="nv">$formattedOptions</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure> <p>Next, we gotta look at each of these connections to see how their API looks to the outside world. Low and behold, each of the connection classes inherits an abstract class called <code class="highlighter-rouge">Connector</code> the binds the connection to a particular API. The <code class="highlighter-rouge">PredisConnection</code> is not too interesting to look at, since it mostly defaults to the abstract class for its functionality. But if you take a look at <code class="highlighter-rouge">PhpRedisConnection</code>, we see that a lot of the commonly used functions like <code class="highlighter-rouge">set</code> and makes sure that it works propery with the PhpRedis client:</p> <figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">set</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$value</span><span class="p">,</span> <span class="nv">$expireResolution</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="nv">$expireTTL</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="nv">$flag</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">command</span><span class="p">(</span><span class="s1">'set'</span><span class="p">,</span> <span class="p">[</span>
        <span class="nv">$key</span><span class="p">,</span>
        <span class="nv">$value</span><span class="p">,</span>
        <span class="nv">$expireResolution</span> <span class="o">?</span> <span class="p">[</span><span class="nv">$flag</span><span class="p">,</span> <span class="nv">$expireResolution</span> <span class="o">=&gt;</span> <span class="nv">$expireTTL</span><span class="p">]</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">]);</span>
<span class="p">}</span></code></pre></figure> <p>We got into the weeds here a bit, but if a third Redis client came into the PHP world, we could easily write a connector and connection for the client and make sure that when we want to perform operations on the Redis server, this adapter will tranform our exact same commands we‚Äôve been sending to be compatible with the new client.</p> <p>We just went through an example with the Redis connection, but this similar pattern applies to database connections as well. Laravel allows us to use different relational SQL databases like MySQL, Postgres, and SQLite. The adapter sits between the database connections and the main app to allow us to write the same application code regardless of our underlying SQL database.</p> <p>Well, I hope that was educational and I encourage the usage of adapters/wrappers whenever we‚Äôre working with third-party code. Until next time, happy coding!</p> </div> </article> <footer class="site-footer"> <div class="container"> <ul class="social"> <li><a href="http://github.com/snags88" target="_blank"><i class="icon icon-github"></i></a></li> <li><a href="http://linkedin.com/in/snaganuma" target="_blank"><i class="icon icon-linkedin"></i></a></li> <li><a href="http://twitter.com/S2k10" target="_blank"><i class="icon icon-twitter"></i></a></li> </ul> <p> <small>&copy;2018 All rights reserved. Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/nandomoreirame/dotX" target="_blank">dotX</a> theme.</small> </p> </div> </footer> </main> <script src="/assets/js/jquery-2.1.1.js"></script> <script src="/assets/js/main.js"></script> </body> </html>