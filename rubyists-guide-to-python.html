<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>Rubyist's guide to Python</title> <meta name="description" content="Ruby was my first programming language and I love it for the simplicity and the syntactic sugar. Python is another popular high-level language used a lot for..."> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="http://snags88.github.io/rubyists-guide-to-python"> <link rel="alternate" type="application/rss+xml" title="gem install Seiji" href="http://snags88.github.io/feed.xml"> <script src="/assets/js/modernizr.js"></script> </head> <body"> <main class="wrapper"> <header class="site-header"> <a href="#navbar" id="menu-burger" class="menu-burger">Menu <span class="nav-icon"></span> <svg x="0px" y="0px" width="54px" height="54px" viewBox="0 0 54 54"> <circle fill="transparent" stroke="#000000" stroke-width="1" cx="27" cy="27" r="25" stroke-dasharray="157 157" stroke-dashoffset="157"></circle> </svg> </a> <div id="navbar" class="navbar"> <div class="navigation-wrapper"> <div class="half-block"> <h2>Navigation</h2> <nav> <ul class="no-style primary-nav"> <li><a href="/">Home</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/about">About</a></li> <li><a href="http://github.com/snags88" target="_blank"><i class="icon icon-github"></i> Github</a></li> <li><a href="http://linkedin.com/in/snaganuma" target="_blank"><i class="icon icon-linkedin"></i> LinkedIn</a></li> <li><a href="http://twitter.com/S2k10" target="_blank"><i class="icon icon-twitter"></i> Twitter</a></li> </ul> </nav> </div> </div> </div> </header> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header intro"> <div class="intro-in"> <h1 class="post-title" itemprop="name headline">Rubyist's guide to Python</h1> <p class="post-meta"><time datetime="2017-05-24T05:30:00-07:00" itemprop="datePublished">May 24, 2017</time></p> </div> </header> <div class="post-content container" itemprop="articleBody"> <p>Ruby was my first programming language and I love it for the simplicity and the syntactic sugar. Python is another popular high-level language used a lot for its data crunching libraries. I wanted to take some time to compare the difference between the two and point out some differences between Ruby and Python.</p> <h2 id="version-managment">Version Managment</h2> <p>Ruby has tools to manage the version of the Ruby language you use like <code class="highlighter-rouge">rvm</code> or <code class="highlighter-rouge">rbenv</code>. These tools allow you to change the Ruby version you are using globally and by project. Additionally, they isolate your gem libraries by Ruby version so that you don’t need to worry about Ruby version compatibility based on the library version.</p> <p>Python has a similar tool called <a href="https://github.com/pyenv/pyenv"><code class="highlighter-rouge">pyenv</code></a>. According to the repo, <code class="highlighter-rouge">pyenv</code> was actually forked from <code class="highlighter-rouge">rbenv</code> so we should expect similar behavior. The easiest way to install <code class="highlighter-rouge">pyenv</code> on a <a href="https://github.com/pyenv/pyenv#homebrew-on-mac-os-x">Mac is to use Homebrew</a>. The alternative is to use their <a href="https://github.com/pyenv/pyenv-installer">installer</a>.</p> <p>Once you have it installed, you can use the documentation for the <a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md">various commands</a>. I ended up doing two things. The first was to update my <code class="highlighter-rouge">~/.bash_profile</code> to initialize <code class="highlighter-rouge">pyenv</code>. You can see the changes in my dotfiles <a href="https://github.com/snags88/dotfiles/blob/6fea99e9a9c59169adbe02cf69b3f9610cde8b34/bash/path.bash#L20-L21">here</a>. Then I just installing the most recent version of Python at this time (v3.6.1) and set it as my global version using</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="gp">$ </span>pyenv global
system
<span class="gp">$ </span>pyenv install 3.6.1
<span class="gp">$ </span>pyenv global 3.6.1
<span class="gp">$ </span><span class="nb">exec</span> <span class="nv">$SHELL</span>
<span class="c"># Refresh your shell environment</span>
<span class="gp">$ </span>python --version
Python 3.6.1</code></pre></figure> <h2 id="libraries">Libraries</h2> <p>In Ruby, we have gems. Gems are just little (well, sometimes big) libraries that we can install in our projects to make development faster. You usually hit the RubyGems hosting service to download the libraries.</p> <p>In Python, the library manager is called <code class="highlighter-rouge">pip</code> and it gets installed with Python if you used the instructions above. You can test it out by typing in <code class="highlighter-rouge">$ which pip</code> in the command line. From there, you can just install various libraries by using the <code class="highlighter-rouge">install</code> command like <code class="highlighter-rouge">pip install flask</code> (Flask is Python’s version of Sinatra in Ruby). <code class="highlighter-rouge">pip</code> goes out to Python Package Index (PyPI) to download all the hosted libraries.</p> <h2 id="project-dependencies">Project Dependencies</h2> <p>For each project, it’s best practice to manage its dependencies in a source file so that the dependent libraries can be reinstalled regardless of what environment you’re in. In Ruby, there’s a handy gem called <a href="https://bundler.io/"><code class="highlighter-rouge">bundler</code></a> that creates a <code class="highlighter-rouge">Gemfile</code> in your project. Whenever you want to recreate the environment, you can run <code class="highlighter-rouge">bundle</code> and all your dependencies will be installed. Magic!</p> <p>I looked for something similar in Python and it seems like there’s 2 things we need:</p> <ol> <li>Create an environment by project so that installed libraries do not leak into other projects.</li> <li>Create a source file that lists are dependencies. We can use this later to install dependencies in other environments.</li> </ol> <p>The solution to the first item was to use <code class="highlighter-rouge">virtualenv</code>. It allows you to spin up virtual environments at will and isolate your work. I’m a huge fan of <a href="https://python-guide-pt-br.readthedocs.io/en/latest/dev/virtualenvs/">this article</a>. It does a nice job of explaining <code class="highlighter-rouge">virtualenv</code> at a high-level, but enough detail to get me going. You can simply install this using <code class="highlighter-rouge">$ pip install virtualenv</code></p> <p>I also used <a href="https://github.com/pyenv/pyenv-virtualenv"><code class="highlighter-rouge">pyenv-virtualenv</code></a> to help create virtual environments with <code class="highlighter-rouge">pyenv</code>. From a high-level this tool takes a version of Python you want to use and creates an <code class="highlighter-rouge">envs</code> directory where you can spin up new virtual environments. Then you can just use that environment as if you’re specifying a version of Python you want to use. This tool needs to be installed via Homebrew <code class="highlighter-rouge">$ brew install pyenv-virtualenv</code>. You’ll also need to initialize this tool in your <a href="https://github.com/snags88/dotfiles/blob/ec1ea56dada60210a65f820916b30302481f51bd/bash/path.bash#L22"><code class="highlighter-rouge">.bash_profile</code></a>.</p> <p>Now to bring actually create a virtual environment for our project, we need to run the following (assuming you’re already in the directory of your project):</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="gp">$ </span>pyenv virtual 3.6.1 my_project
<span class="c"># Creates a virtual environment for us. Check it out in ~/.pyenv/versions/</span>
<span class="gp">$ </span>pyenv <span class="nb">local </span>my_project
<span class="c"># Sets the local directory's Python version to be the virtual env we just created inside .python-version</span></code></pre></figure> <p>The solution to the second item (the source file) is that <code class="highlighter-rouge">pip</code> uses a <code class="highlighter-rouge">requirements.txt</code> file in the project to determine the dependencies. Seems like there’s a <code class="highlighter-rouge">$ pip freeze</code> command that we just need to output into the file. When we need to install the dependencies, we just run an install command:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="gp">$ </span>pip freeze &gt; requirements.txt
<span class="c"># Output dependencies into file</span>

<span class="gp">$ </span>pip install -r requirements.txt
<span class="c"># Install all dependencies</span></code></pre></figure> <p>It would be nice for the requirements file to be updated automatically like <code class="highlighter-rouge">bundler</code>, but after some Googling around, I couldn’t find any tools or libraries to help with that. I wonder why it doesn’t get auto-generated after each install…</p> <h2 id="interactive-interpreter">Interactive Interpreter</h2> <p>One of the ways I like to get familar with or test out behavior of a programming language is through a interactive interpretor. In Ruby, there are a few options like <code class="highlighter-rouge">irb</code> and <a href="http://pryrepl.org/"><code class="highlighter-rouge">pry</code></a>.</p> <p>In Python, you can just run the <code class="highlighter-rouge">$ python</code> command to enter an interactive session. I haven’t found any alternatives for a Python REPL but I’m sure there are alternatives to what comes out of the box.</p> <h2 id="syntax">Syntax</h2> <p>This is a pretty large topic so I’ll try to start small from working with more primative types and go into creating classes, etc.</p> <h3 id="numbers">Numbers</h3> <p>Most things are pretty much the same as Ruby except for 2 things I noticed:</p> <ol> <li>In Python, division always returns a float value even if it’s perfectly divisible. Ruby always rounds down to the nearest integer.</li> <li>In Python, there is a “floor division” operator <code class="highlighter-rouge">//</code> that will round the division down to the nearest integer, similar to how Ruby’s regular division works.</li> </ol> <h3 id="strings">Strings</h3> <p>Strings operate pretty similar to Ruby as well. Concatenation is done with <code class="highlighter-rouge">+</code>. 2 major differences I think are important to note are string interpolation and printing strings:</p> <ul> <li>Starting with v3.6, Python allows string interpolation using “f-strings”. <a href="https://stackoverflow.com/a/4450610">This Stack Overflow answer</a> does a nice job of summarizing the various ways of string interpolation.</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="n">interpolate_me</span> <span class="o">=</span> <span class="s">"I'm interpolated!"</span>
  <span class="n">f</span><span class="s">"Interpolate a variable: {interpolate_me}"</span>
  </code></pre></figure> <ul> <li>In Python, printing things out uses the <code class="highlighter-rouge">print()</code> function. In Ruby, <code class="highlighter-rouge">puts</code> is used.</li> </ul> <h3 id="absence-of-a-value">Absence of a value</h3> <p>Ruby uses <code class="highlighter-rouge">nil</code> to represent the absence of a value. Python uses a singlton called <code class="highlighter-rouge">None</code>.</p> <h3 id="truthy--falsy-values">Truthy &amp; Falsy values</h3> <p>In Ruby, all values are truthy except for <code class="highlighter-rouge">false</code> and <code class="highlighter-rouge">nil</code>. In Python, there is a larger list of items that are falsy like <code class="highlighter-rouge">0</code>, any empty list, empty string, and <code class="highlighter-rouge">None</code>. There are more values in this list and you can check the entire list <a href="https://stackoverflow.com/a/39984051">here</a>.</p> <h3 id="arrays">Arrays</h3> <p>Arrays pretty much work the same between the two languages, but the method names are a little different (i.e. <code class="highlighter-rouge">push</code> in Ruby is <code class="highlighter-rouge">append</code> in Python).</p> <p>The only thing I noticed was that in Python, you cannot assign an element at an array’s index if nothing exists at that index.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ERROR</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">arr</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span></code></pre></figure> <h3 id="hash-dictionary">Hash dictionary</h3> <p>In Ruby, key-value pairs stored in a data structure (<code class="highlighter-rouge"><span class="p">{}</span></code>) are called hashes. In Python, they are called dictionaries. They seem to work the same. The only thing to be careful for in Python is that the hashes <code class="highlighter-rouge"><span class="p">{}</span></code> are also used to describe “sets” which are like arrays, but with no duplicate values.</p> <h3 id="variables">Variables</h3> <p>Variable assignments are the exact same in Ruby. No special keyword to declare it, but you need to declare a variable before you use it. Otherwise you get an exception.</p> <h3 id="defining-functionsmethods">Defining functions/methods</h3> <p>In Ruby, methods are defined by using the <code class="highlighter-rouge">def</code> and <code class="highlighter-rouge">end</code> keyword:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
  <span class="n">argument</span> <span class="c1">#=&gt; implicit return of argument</span>
<span class="k">end</span></code></pre></figure> <p>In Python, functions are defined similarly, except it’s more dependent on indentation and requires an explicit return value:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">argument</span> <span class="c">#=&gt; explicit return of argument</span></code></pre></figure> <p>The other things to note is that Ruby uses the colon <code class="highlighter-rouge">:</code> for keyword arguments, whereas Python uses the equal <code class="highlighter-rouge">=</code>.</p> <h3 id="scoping-rules">Scoping Rules</h3> <p>In my experience, Ruby’s scoping rules follow a narrow set of rules and are pretty understandable. I learned about how to determine the scope by using the scope gate rules: any time a method, module, or class is defined a new scope is created. Also, there is a global scope that’s at the top level.</p> <p>For example the following code snippet makes sense:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">a</span> <span class="o">=</span> <span class="s1">'global variable'</span>

<span class="k">def</span> <span class="nf">test_method</span>
  <span class="n">a</span> <span class="o">=</span> <span class="s1">'local variable'</span>
  <span class="nb">puts</span> <span class="n">a</span> <span class="c1">#=&gt; prints 'local variable' due to shadowing. imagine it as a new "a" variable inside of this scope</span>

  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">num</span>
  <span class="k">end</span>

  <span class="nb">puts</span> <span class="n">a</span> <span class="c1">#=&gt; prints '3' because we reassigned the variable in the loop above</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">a</span> <span class="c1">#=&gt; prints global variable from global scope</span>
<span class="n">test_method</span>
<span class="nb">puts</span> <span class="n">a</span> <span class="c1">#=&gt; prints global variable because variable was modified inside of another scope</span></code></pre></figure> <p>As I’ve been reading about Python’s scoping rules, it works similarly, but Python really emphasizes the concept of “Namespaces” that maintains the various namespaces and variables within the namespaces using a dictionary (or a ruby hash). As variables are used, Python searches the appropriate namespaces in the order of <strong>Local</strong>, <strong>Enclosed</strong>, <strong>Global</strong>, and <strong>Built-in</strong> (commonly refered to as LEGB). If nothing is found in any of those namespaces, then a <em>NameError</em> is raised. So at the end of the day, the below snippet written in Python acts the same as the one above in Ruby:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="s">'global variable'</span>

<span class="k">def</span> <span class="nf">test_method</span> <span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">'local variable'</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints 'local variable' due to shadowing. imagine it as a new "a" variable inside of this scope</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">num</span>

    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints '3' because we reassigned the variable in the loop above</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints global variable from global scope</span>
<span class="n">test_method</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints global variable because variable was modified inside of another scope</span></code></pre></figure> <p>The more interesting part for Python is that there are keywords you can use to actually reference the variables declared in the global or enclosing functions. I’m actually not sure how useful this is due to potential confusion and modifying out of scope variables unintentionally, which could lead to unwanted side effects. In any case, you can do this by using <code class="highlighter-rouge">global</code> or <code class="highlighter-rouge">nonlocal</code>:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="s">'global variable'</span>

<span class="k">def</span> <span class="nf">test_method</span> <span class="p">():</span>
    <span class="k">global</span> <span class="n">a</span> <span class="c">#=&gt; Tells python to us the globally decalred "a" variable</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">'local variable'</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints 'local variable' due to reassignment of the variable</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">num</span>

    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints '3' because we reassigned the variable in the loop above</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints global variable from global scope</span>
<span class="n">test_method</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">#=&gt; prints 3 because the global "a" variable was used inside of "test_method"</span></code></pre></figure> <h3 id="function-objects">Function objects</h3> <p>In Ruby, methods can’t really be passed around. They need to be wrapped in a Proc or Lamda object. In Python, functions need to be invoked, so if you just have a reference to a function or a method, you can actually pass that around or set them to other variables for access at a later point in time.</p> <h3 id="classes--objects">Classes &amp; Objects</h3> <p>I’m not going to get too much into the intricates of Ruby’s classes here because this is assuming that we know Ruby pretty well. For Python, there are some similarities, but much more noticeable differences compared to some of the other things we looked into already.</p> <ul> <li>You can declare attributes in the body of the class like variables. You can reassign the attributes after class definition and object instantiation:</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">123</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">MyClass</span> <span class="c">#=&gt; Class def</span>
  <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="c">#=&gt; 123</span>
  <span class="n">c</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">789</span>
  <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="c">#=&gt; 789</span>
  <span class="n">o</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span> <span class="c">#=&gt; Instance of class</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="c">#=&gt; 789</span>
  <span class="n">o</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">456</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="c">#=&gt; 456</span>
  </code></pre></figure> <ul> <li>The attributes declared in the class body are class variables. Attributes assigned to <code class="highlighter-rouge">self</code> are instance variables:</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="n">class_variable</span> <span class="o">=</span> <span class="s">'hello from class variable!'</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">instance_variable</span> <span class="o">=</span> <span class="n">name</span>

  <span class="n">o1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">'first object!'</span><span class="p">)</span>
  <span class="n">o2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">'second object!'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">class_variable</span><span class="p">)</span> <span class="c">#=&gt; 'hello from class variable!'</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">class_variable</span><span class="p">)</span> <span class="c">#=&gt; 'hello from class variable!'</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">instance_variable</span><span class="p">)</span> <span class="c">#=&gt; 'first object!'</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">instance_variable</span><span class="p">)</span> <span class="c">#=&gt; 'second object!'</span>
  </code></pre></figure> <ul> <li>The lifecycle hook for object instantiation is <code class="highlighter-rouge">def __init__(self)</code></li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">first_arg</span> <span class="o">=</span> <span class="n">arg1</span>

  <span class="n">o</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">'first argument!'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">first_arg</span><span class="p">)</span> <span class="c">#=&gt; 'first argument!'</span>
  </code></pre></figure> <ul> <li>The first argument in a method definition is the <code class="highlighter-rouge">self</code> keyword (or <code class="highlighter-rouge">cls</code> for class methods). It can be used to get a reference to the current object or class in the method definition</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">set_b</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>

  <span class="n">o</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
  <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="c">#=&gt; 10</span>
  </code></pre></figure> <ul> <li>Python lets you do multiple inheritance. The ways method calls are looked up is from left to right in the inheritance declaration and depth first. However, Python will make sure that each base class is only looked up once:</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">BaseClass1</span><span class="p">,</span> <span class="n">BaseClass2</span><span class="p">):</span>
    <span class="c"># Define class here with `super()` and stuff</span>
  </code></pre></figure> <ul> <li>Python doesn’t enforce private variables or methods. It’s up to the developer to denote the private methods by using a single or double underscore before the method name. When this is done, it will actually namespace those attributes or methods with the name of the class. This is called <em>name mangling</em>:</li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">print</span><span class="p">(</span><span class="s">'public method'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">print</span><span class="p">(</span><span class="s">'private method'</span><span class="p">)</span>

  <span class="n">o</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
  <span class="n">o</span><span class="o">.</span><span class="n">public_method</span> <span class="c">#=&gt; 'public method'</span>
  <span class="n">o</span><span class="o">.</span> <span class="n">__private_method</span> <span class="c">#=&gt; Throws exception</span>
  <span class="n">o</span><span class="o">.</span><span class="n">_MyClass__private_method</span> <span class="c">#=&gt; 'private method'</span>
  </code></pre></figure> <h2 id="modules">Modules</h2> <p>For code organization, it’s nice to keep similar code like a class definition or utility functions in a single file. Ruby uses the keyword <code class="highlighter-rouge">require</code> to import the code into another file. Rails does a lot of magic behind the scenes to make things available to you everywhere in your code source.</p> <p>For Python, a similar concept applies, but each file has its own namespace and we use the <code class="highlighter-rouge">import</code> keyword to get code from one file into another. The filename and the module name should match and there’s a set of rules for how it finds the files in detail <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path">here</a>. After you’ve imported a module, you can access its namespaced attributes by using dot notation:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># module.py</span>
<span class="k">def</span> <span class="nf">printer</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">multiplier</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Hello, my name is '</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="s">'!'</span><span class="p">)</span>

<span class="c"># import.py</span>
<span class="kn">import</span> <span class="nn">module</span>

<span class="n">module</span><span class="o">.</span><span class="n">printer</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span> <span class="c">#=&gt; prints 'hello'</span>
<span class="n">module</span><span class="o">.</span><span class="n">multiplier</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c">#=&gt; prints '8'</span>

<span class="n">o</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">MyClass</span><span class="p">(</span><span class="s">'Seiji'</span><span class="p">)</span>
<span class="n">o</span><span class="o">.</span><span class="n">say_hello</span><span class="p">()</span> <span class="c">#=&gt; prints 'Hello, my name is Seiji!'</span></code></pre></figure> <p>Also important to note that you can import specific names from your module by doing <code class="highlighter-rouge">from module_name import name1, name2</code> or just import everything into the current namespace by doing <code class="highlighter-rouge">from module_name import *</code>.</p> <p>Extending this idea of module imports, you can imagine this is how we can share behavior across different classes and mix them into our class definition:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">module</span>

<span class="k">class</span> <span class="nc">MyOtherClass</span><span class="p">:</span>
  <span class="n">printer</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">printer</span>
  <span class="n">multiplier</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">multiplier</span></code></pre></figure> <h2 id="conclusion">Conclusion</h2> <p>There are actually more similarities between Python and Ruby than I imagined. Of course there are syntactic differences, but they both are easy to use. Python tends to lean on the side of more explicitness (which is not a bad thing), where as Ruby has some niceness in terms of the developer experience. At the end of the day, the choice of language depends on the problem you’re trying to solve. My next step is to start playing with Django, the Rails equivalent web framework for the Python language.</p> </div> </article> <footer class="site-footer"> <div class="container"> <ul class="social"> <li><a href="http://github.com/snags88" target="_blank"><i class="icon icon-github"></i></a></li> <li><a href="http://linkedin.com/in/snaganuma" target="_blank"><i class="icon icon-linkedin"></i></a></li> <li><a href="http://twitter.com/S2k10" target="_blank"><i class="icon icon-twitter"></i></a></li> </ul> <p> <small>&copy;2018 All rights reserved. Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/nandomoreirame/dotX" target="_blank">dotX</a> theme.</small> </p> </div> </footer> </main> <script src="/assets/js/jquery-2.1.1.js"></script> <script src="/assets/js/main.js"></script> </body> </html>